<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Light</title>
    <style>
        body {
            display: flex;
            background-color: rgb(26, 26, 26);
        }

        canvas {
            margin: auto;
        }
    </style>
</head>

<body></body>

<script type="module">
    // --- Imports ---
    import Canvas from "./src/Canvas.js";
    import Color from "./src/Color.js";
    import Vec, { Vec2 } from "./src/Vector.js";
    import { Pane } from "./tweakpane-4.0.4.min.js";
    import localStorage from "./src/LocalStorage.js"

    function sdfIntercept(init, dir, element) {
        const maxIte = 50;
        const epsilon = 1e-3;
        let p = init;
        let t = element.distanceTo(p);
        let minT = t;
        for (let i = 0; i < maxIte; i++) {
            p = init.add(dir.scale(t * 0.999));
            const d = element.distanceTo(p);
            t += d;
            if (d < epsilon) {
                return [t, p.add(dir.scale(-epsilon))];
            }
            if (d > minT) {
                return;
            }
            minT = d;
        }
        return;
    }

    // --- Scene Elements ---
    function Line(args = {}) {
        const { name, positions, color, radius, emissive } = args;
        let v, n;
        if (positions) {
            v = positions[1].sub(positions[0]);
            n = Vec2(-v.y, v.x).normalize();
        }
        const line = { name, positions, color, radius, emissive };
        line.distanceTo = (p) => {
            const x = p.sub(line.positions[0]);
            const h = Math.min(1, Math.max(0, x.dot(v) / v.dot(v)));
            return x.sub(v.scale(h)).length() - line.radius;
        };
        line.normal = (p) => {
            const epsilon = 1e-3;
            const f = line.distanceTo(p);
            const fx = line.distanceTo(p.add(Vec2(epsilon, 0)));
            const fy = line.distanceTo(p.add(Vec2(0, epsilon)));
            return Vec2((fx - f) / epsilon, (fy - f) / epsilon).normalize();
        };
        line.sample = () => {
            const r = Math.random();
            return positions[0].scale(1 - r).add(positions[1].scale(r));
        };
        line.interceptWith = (init, dir) => {
            const hit = sdfIntercept(init, dir, line);
            if (hit) return [...hit, line.normal(hit[1])];
        };
        line.serialize = () => ({
            type: "line",
            name,
            positions: positions.map(p => p.toArray()),
            color: color.toArray(),
            radius,
            emissive
        });
        line.deserialize = (json) => Line({
            name: json.name,
            radius: json.radius,
            emissive: json.emissive,
            positions: json.positions.map(p => Vec2(p[0], p[1])),
            color: Color.ofRGB(...json.color)
        });
        return line;
    }

    function Point(args = {}) {
        const { name, position, color, radius, emissive } = args;
        const point = { name, position, color, radius, emissive };
        point.distanceTo = (p) => {
            return p.sub(point.position).length() - point.radius;
        }

        point.normal = (p) => {
            return p.sub(point.position).normalize()
        }

        point.sample = () => {
            const theta = 2 * Math.PI * Math.random();
            return Vec2(
                point.radius * Math.cos(theta) + point.position.x,
                point.radius * Math.sin(theta) + point.position.y
            );
        };
        point.interceptWith = (init, dir) => {
            const hit = sdfIntercept(init, dir, point);
            if (hit) return [...hit, point.normal(hit[1])];
        };
        point.serialize = () => ({
            type: "point",
            name,
            position: position.toArray(),
            color: color.toArray(),
            radius,
            emissive
        });
        point.deserialize = (json) => Point({
            name: json.name,
            position: Vec2(json.position[0], json.position[1]),
            color: Color.ofRGB(...json.color),
            radius: json.radius,
            emissive: json.emissive
        });
        return point;
    }

    function intersectScene(init, dir, scene) {
        let closest = undefined;
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < scene.length; i++) {
            const e = scene[i];
            const hit = e.interceptWith(init, dir);
            if (hit) {
                const [t, p, n] = hit;
                if (t < minDist) {
                    minDist = t;
                    closest = [p, n, e];
                }
            }
        }
        return closest;
    }
    // --- Parameters & GUI ---
    const PARAMS = {};
    const pane = new Pane({ title: "Parameters" });
    const btn = pane.addButton({ title: 'fullscreen' });
    btn.on("click", () => toggleFullScreen(canvasDom));
    function toggleFullScreen(elem) {
        if (
            !document.fullscreenElement &&
            !document.mozFullScreenElement &&
            !document.webkitFullscreenElement &&
            !document.msFullscreenElement
        ) {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        }
    }

    // --- Animation Loop ---

    const w = 640;
    const h = 480;
    const size = Vec2(w, h);
    const canvas = Canvas.ofSize(w, h);

    // --- Mouse Handling ---
    let mousedown = false;
    let mouse = Vec2();
    let pointer = mouse;
    let scale = 5;
    let center = Vec2();
    let path = [];
    let isNewScene = true;
    canvas.onMouseDown((x, y) => {
        mousedown = true;
        mouse = Vec2(x, y);
        path.push(mouse.clone())
    })
    canvas.onMouseUp(() => {
        mousedown = false;
        mouse = Vec2();
        let id = scene.length;
        for (let i = 0; i < path.length - 1; i++) {
            scene.push(
                Line({
                    name: `id_${id}`,
                    positions: [
                        path[i].div(size).map(x => 2 * x - 1).scale(scale).add(center),
                        path[i + 1].div(size).map(x => 2 * x - 1).scale(scale).add(center)
                    ],
                    radius: 0.1,
                    emissive: true,
                    color: Color.WHITE
                })
            )
        }
        isNewScene = true;
        path = [];
    })
    canvas.onMouseMove((x, y) => {
        const newMouse = Vec2(x, y);
        pointer = newMouse;
        if (!mousedown || newMouse.equals(mouse)) {
            return;
        }
        const [dx, dy] = newMouse.sub(mouse).toArray();
        path.push(newMouse.clone());
        mouse = newMouse;
    });

    canvas.onMouseWheel(({ deltaY }) => {
    })

    let scene = [];
    function rayTrace(x, normal, scene, options = {}) {
        const { bounces } = options;
        // Base case: no more bounces
        if (bounces < 0) {
            return Color.BLACK;
        }

        // Random direction, reflect if normal provided
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) < 0) v = v.scale(-1);

        // Intersect scene
        const hit = intersectScene(x, v, scene);
        if(!hit) {
            return Color.BLACK;
        }
        const [p, n, e] = hit;
        return rayTrace(p, n, { ...options, bounces: bounces - 1 }, scene, cache).mul(e.color);
    }

    // --- Render Functions ---
    function render(params) {
        const { samplesPerPxl = 1 } = params || {};
        return canvas.map((x, y) => {
            const gridSpace = 0.5;
            const px = scale * (2 * (x / w) - 1) + center.x;
            const py = scale * (2 * (y / h) - 1) + center.y;
            const p = Vec2(px, py);
            let color = Color.BLACK
            for (let i = 0; i < samplesPerPxl; i++) {
                const theta = 2 * Math.PI * Math.random();
                const dir = Vec2(Math.cos(theta), Math.sin(theta));
                color = color.add(radianceCascades.get(p, dir, 1));
            }
            for (let i = 0; i < samplesPerPxl; i++) {
                const theta = 2 * Math.PI * Math.random();
                const dir = Vec2(Math.cos(theta), Math.sin(theta));
                color = color.add(radianceCascades.get(p, dir, 0));
            }
            color = color.scale(1 / (2 * samplesPerPxl));
            return color;
        });

    }


    const radianceCascades = ((gridSize) => {
        const cache = new Map();
        return {
            put: (x, dir, color, level) => {
                const key = `${x.x},${x.y},${dir.x},${dir.y},${level}`;
                if (!cache.has(key)) {
                    cache.set(key, { color, level });
                } else {
                    const existing = cache.get(key);
                    if (existing.level < level) {
                        existing.color = existing.color.add(color);
                        existing.level = level;
                    }
                }
            },
            get: (x, dir, level) => {
                const key = `${x.x},${x.y},${dir.x},${dir.y},${level}`;
                return cache.get(key)?.color || Color.BLACK;
            },
            clear: () => cache.clear(),
        };
    })(0.5)
    function updateLight(params = {}) {
        const { bounces, samplesPerPxl, variance, gamma } = params;
        const invSamples = (bounces || 1) / samplesPerPxl;
        let gridSize = 0.5;
        let n = (2 * scale) / gridSize;
        let nn = n * n;
        let m = 4;
        let level = 0;
        for (let k = 0; k < nn; k++) {
            const i = Math.floor(k / n);
            const j = k % n;
            const x = center.add(Vec2(i, j).scale(gridSize));
            for (let l = 0; l < m; l++) {
                const theta = ((2 * Math.PI) / m) * l;
                const dir = Vec2(Math.cos(theta), Math.sin(theta));
                radianceCascades.put(x, dir, rayTrace(x, scene, { bounces }), level);
            }
        }

        gridSize = gridSize * 2;
        n = (2 * scale) / gridSize;
        nn = n * n;
        m = m * m;
        level++;

        for (let k = 0; k < nn; k++) {
            const i = Math.floor(k / n);
            const j = k % n;
            const x = this.center.add(Vec2(i, j).scale(gridSize));
            for (let l = 0; l < m; l++) {
                const theta = ((2 * Math.PI) / m) * l;
                const dir = Vec2(Math.cos(theta), Math.sin(theta));
                radianceCascades.put(x, dir, rayTrace(x, scene, { bounces }), level);
            }
        }
    }


    const play = async ({ time, oldT }) => {
        const newT = new Date().getTime();
        const dt = (newT - oldT) * 1e-3;
        document.title = `2D Light, FPS: ${((1 / dt).toFixed(2))}`;
        //updateLight(PARAMS);
        render().paint();
        // debug(scene);
        requestAnimationFrame(() => play({
            oldT: newT,
            time: time + dt,
        }));
    };
    requestAnimationFrame(() => play({ oldT: new Date().getTime(), time: 0 }));

    // --- DOM Setup ---
    const canvasDom = canvas.DOM;
    const container = document.createElement("div");
    container.setAttribute("style", "display: flex; flex-grow: 1; margin: auto");
    canvasDom.setAttribute("style", "flex-grow: 0.5");
    container.appendChild(canvasDom);
    document.body.appendChild(container);

</script>

</html>