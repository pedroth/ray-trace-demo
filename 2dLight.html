<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Light</title>
    <style>
        body {
            display: flex;
            background-color: rgb(26, 26, 26);
        }

        canvas {
            margin: auto;
        }
    </style>
</head>

<body>

</body>
<script type="module">
    import Canvas from "./Canvas.js";
    import Color from "./Color.js";
    import { Vec2 } from "./Vector.js";

    const w = 640 / 2;
    const h = 480 / 2;
    const canvas = Canvas.ofSize(w, h);
    let exposedCanvas = canvas.exposure();
    const lightCache = (gridSpace) => {
        const probabilityMap = {};
        let total = 1;
        const ans = {};
        ans.hash = (p) => {
            const integerCoord = p.map(z => Math.floor(z / gridSpace));
            const h = (integerCoord.x * 92837111) ^ (integerCoord.y * 689287499);
            return Math.abs(h);
        }
        ans.put = p => {
            total++;
            const h = ans.hash(p);
            probabilityMap[h] = (probabilityMap[h] || 1) + 1;
        }
        ans.get = p => {
            const h = ans.hash(p);
            const count = probabilityMap[h];
            if (!count) return 1;
            return Math.log(-probabilityMap[h] / total);
        }
        return ans;
    }
    let lightField = lightCache(1);

    // mouse handling
    let mousedown = false;
    let mouse = Vec2();
    let pointer = mouse;
    let scale = 5;
    let center = Vec2();
    canvas.onMouseDown((x, y) => {
        mousedown = true;
        mouse = Vec2(x, y);

    })
    canvas.onMouseUp(() => {
        mousedown = false;
        mouse = Vec2();
    })
    canvas.onMouseMove((x, y) => {
        const newMouse = Vec2(x, y);
        pointer = newMouse;
        if (!mousedown || newMouse.equals(mouse)) {
            return;
        }
        const [dx, dy] = newMouse.sub(mouse).toArray();
        center = center.add(Vec2(dx, dy));
        mouse = newMouse;
        exposedCanvas = canvas.exposure();
    })
    canvas.onMouseWheel(({ deltaY }) => {
        scale = scale + deltaY * 0.001;
        exposedCanvas = canvas.exposure();
    })


    function sdfIntercept(init, dir, element) {
        const maxIte = 50;
        const epsilon = 1e-3;
        let p = init;
        let t = element.distanceTo(p);
        let minT = t;
        for (let i = 0; i < maxIte; i++) {
            p = init.add(dir.scale(t * 0.999));
            const d = element.distanceTo(p);
            t += d;
            if (d < epsilon) {
                return p.add(dir.scale(-epsilon));
            }
            if (d > minT) {
                return;
            }
            minT = d;
        }
        return;
    }

    // scene
    function Line({ name, positions, color, radius, emissive }) {
        const v = positions[1].sub(positions[0]);
        const n = Vec2(-v.y, v.x).normalize();
        const line = { name, positions, color, radius, emissive };
        line.distanceTo = (p) => {
            const x = p.sub(line.positions[0]);
            const h = Math.min(1, Math.max(0, x.dot(v) / v.dot(v)));
            return x.sub(v.scale(h)).length() - line.radius;
        }

        line.normal = (p) => {
            const epsilon = 1e-3;
            const f = line.distanceTo(p);
            const fx = line.distanceTo(p.add(Vec2(epsilon, 0)));
            const fy = line.distanceTo(p.add(Vec2(0, epsilon)));
            return Vec2((fx - f) / epsilon, (fy - f) / epsilon).normalize();
        }

        line.interceptWith = (init, dir) => {
            const p = sdfIntercept(init, dir, line);
            if (p) return [p, line.normal(p)];
        }
        return line;
    }

    function Point({ name, position, color, radius, emissive }) {
        const point = { name, position, color, radius, emissive };
        point.distanceTo = (p) => {
            return p.sub(point.position).length() - point.radius;
        }

        point.normal = (p) => {
            return p.sub(point.position).normalize()
        }
        point.interceptWith = (init, dir) => {
            const p = sdfIntercept(init, dir, point);
            if (p) return [p, point.normal(p)];
        }
        return point;
    }

    function intersectScene(init, dir) {
        let closest = undefined;
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < scene.length; i++) {
            const e = scene[i];
            const hit = e.interceptWith(init, dir);
            if (hit) {
                const [p, n] = hit;
                const length = p.sub(init).length();
                if (length < minDist) {
                    minDist = length;
                    closest = [p, n, e];
                }
            }
        }
        return closest;
    }

    function trace(x, normal, bounces) {
        if (bounces < 0) return Color.BLACK;
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) < 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) return Color.BLACK;

        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) return color;
        const finalC = trace(p, n, bounces - 1);
        return finalC.mul(color);
    }

    function traceCache(x, normal, bounces) {
        const prob = lightField.get(x);
        if (Math.random() >= prob) return Color.BLACK;
        if (bounces < 0) return Color.BLACK;
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) < 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) return Color.BLACK;
        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) return color;
        const finalC = traceCache(p, n, bounces - 1);
        if (!finalC.equals(Color.BLACK)) {
            lightField.put(x);
        }
        return finalC.mul(color);
    }

    function biTrace(x, normal, bounces) {
        if (bounces < 0) return colorFromLight(x, normal);
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) < 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) return Color.BLACK;

        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) return color;
        const finalC = biTrace(p, n, bounces - 1);
        return finalC.mul(color);
    }

    function colorFromLight(p, n) {
        const emissiveElements = scene.filter((e) => e.emissive);
        for (let i = 0; i < emissiveElements.length; i++) {
            const light = emissiveElements[i];
            const v = light.normal(p).scale(-1);
            if (v.dot(n) < 0) continue;
            const hit = intersectScene(p, v);
            if (!hit) continue;
            if (hit) {
                const [p, n, e] = hit;
                const color = e.color;
                if (e.emissive) return color;
            };
        }
        return Color.BLACK;
    }


    function debugTrace(x, normal, bounces) {
        if (bounces < 0) return
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) <= 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) {
            if (normal) {
                let p = x.add(v.scale(2));
                canvas.drawLine(
                    Vec2(((x.x / scale) + 1) * (w / 2) + center.x, ((x.y / scale) + 1) * (h / 2) + center.y),
                    Vec2(((p.x / scale) + 1) * (w / 2) + center.x, ((p.y / scale) + 1) * (h / 2) + center.y),
                    () => Color.ofRGB(1, 0, 1)
                )
            }
            return;
        }
        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) {
            canvas.drawLine(
                Vec2(((x.x / scale) + 1) * (w / 2) + center.x, ((x.y / scale) + 1) * (h / 2) + center.y),
                Vec2(((p.x / scale) + 1) * (w / 2) + center.x, ((p.y / scale) + 1) * (h / 2) + center.y),
                () => e.color
            )
            return;
        };
        canvas.drawLine(
            Vec2(((x.x / scale) + 1) * (w / 2) + center.x, ((x.y / scale) + 1) * (h / 2) + center.y),
            Vec2(((p.x / scale) + 1) * (w / 2) + center.x, ((p.y / scale) + 1) * (h / 2) + center.y),
            () => color
        )
        debugTrace(p, n, bounces - 1);
    }

    const scene = [
        Point({ name: "light", position: Vec2(), radius: 0.1, emissive: true, color: Color.WHITE }),
        Line({ name: "left", positions: [Vec2(-1.5, -1.5), Vec2(-1.5, 1.5)], radius: 0.1, color: Color.RED }),
        Line({ name: "right", positions: [Vec2(1.5, 1.5), Vec2(1.5, -1.5)], radius: 0.1, color: Color.GREEN }),
        Line({ name: "top", positions: [Vec2(-1.5, 1.5), Vec2(1.5, 1.5)], radius: 0.1, color: Color.WHITE }),
        Line({ name: "wall-1", positions: [Vec2(-0.5, -0.5), Vec2(0, -0.5)], radius: 0.1, color: Color.BLUE }),
        Line({ name: "wall-2", positions: [Vec2(0.5, -1), Vec2(1.0, -1)], radius: 0.1, color: Color.BLUE }),
    ]


    // play
    const play = async ({ time, oldT }) => {
        const newT = new Date().getTime();
        const dt = (new Date().getTime() - oldT) * 1e-3;
        exposedCanvas
            .map((x, y) => {
                const px = scale * (2 * (x - center.x) / w - 1);
                const py = scale * (2 * (y - center.y) / h - 1);
                return trace(Vec2(px, py), undefined, 10);
            })
        // exposedCanvas
        //     .map((x, y) => {
        //         const px = scale * (2 * (x - center.x) / w - 1);
        //         const py = scale * (2 * (y - center.y) / h - 1);
        //         return traceCache(Vec2(px, py), undefined, 10);
        //     })
        // exposedCanvas
        //     .map((x, y) => {
        //         const px = scale * (2 * (x - center.x) / w - 1);
        //         const py = scale * (2 * (y - center.y) / h - 1);
        //         return biTrace(Vec2(px, py), undefined, 3);
        //     })
        // exposedCanvas
        //     .map((x, y) => {
        //         const px = scale * (2 * (x - center.x) / w - 1);
        //         const py = scale * (2 * (y - center.y) / h - 1);
        //         return trace(Vec2(px, py), undefined, 10).scale(0.75)
        //             .add(biTrace(Vec2(px, py), undefined, 2).scale(0.25))
        //             .toGamma(0.1);
        //     })
        // exposedCanvas
        //     .map((x, y) => {
        //         let c = Color.BLACK;
        //         let step = [-1, 0, 1];
        //         let n = step.length;
        //         let nn = n * n;
        //         for (let i = 0; i < nn; i++) {
        //             let j = step[Math.floor(i / n)];
        //             let k = step[i % n];
        //             const px = scale * (2 * ((x + j) - center.x) / w - 1);
        //             const py = scale * (2 * ((y + k) - center.y) / h - 1);
        //             c = c.add(trace(Vec2(px, py), undefined, 10));
        //         }
        //         return c.scale(1 / nn).toGamma(0.0001);
        //     })
        // exposedCanvas.map((x, y) => Color.BLACK);
        // debugTrace(
        //     Vec2(
        //         scale * (2 * ((pointer.x - center.x) / w) - 1),
        //         scale * (2 * ((pointer.y - center.y) / h) - 1),
        //     ),
        //     undefined,
        //     1
        // )
        // scene[0].position = Vec2(Math.cos(time), Math.sin(time));
        setTimeout(() => play({
            oldT: newT,
            time: time + dt,
        }));
    }
    setTimeout(() => play({ oldT: new Date().getTime(), time: 0 }))



    // DOM
    function toggleFullScreen(elem) {
        if (!document.fullscreenElement &&    // alternative standard method
            !document.mozFullScreenElement &&
            !document.webkitFullscreenElement &&
            !document.msFullscreenElement) {  // current working methods
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        }
    }
    const canvasDom = canvas.DOM;
    canvasDom.addEventListener("click", () => {
        toggleFullScreen(canvasDom);
    })
    document.body.appendChild(canvas.DOM);
</script>

</html>