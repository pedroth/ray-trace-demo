<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Light</title>
    <style>
        body {
            display: flex;
            background-color: rgb(26, 26, 26);
        }

        canvas {
            margin: auto;
        }
    </style>
</head>

<body>

</body>
<script type="module">
    import Canvas from "./Canvas.js";
    import Color from "./Color.js";
    import { Vec2 } from "./Vector.js";

    const w = 640 / 2;
    const h = 480 / 2;
    const canvas = Canvas.ofSize(w, h);
    let exposedCanvas = canvas.exposure();
    const colorCache = (gridSpace) => {
        const probabilityMap = {};
        const ans = {};
        ans.total = 1;
        ans.hash = (p) => {
            const integerCoord = p.map(z => Math.floor(z / gridSpace));
            const h = (integerCoord.x * 92837111) ^ (integerCoord.y * 689287499);
            return Math.abs(h);
        }
        ans.put = (p, c) => {
            ans.total = ans.total + 1;
            const h = ans.hash(p);
            if (!(h in probabilityMap)) {
                probabilityMap[h] = { color: Color.BLACK, count: 1 };
            }
            const res = probabilityMap[h]
            probabilityMap[h] = {
                color: Color.ofRGB(
                    c.red + (res.color.red - c.red) / res.count,
                    c.green + (res.color.green - c.green) / res.count,
                    c.blue + (res.color.blue - c.blue) / res.count
                ),
                count: res.count + 1
            }
            return ans;
        }
        ans.get = p => {
            const h = ans.hash(p);
            return probabilityMap[h];
        }
        return ans;
    }
    let colorField = colorCache(0.2);

    // mouse handling
    let mousedown = false;
    let mouse = Vec2();
    let pointer = mouse;
    let scale = 5;
    let center = Vec2();
    canvas.onMouseDown((x, y) => {
        mousedown = true;
        mouse = Vec2(x, y);

    })
    canvas.onMouseUp(() => {
        mousedown = false;
        mouse = Vec2();
    })
    canvas.onMouseMove((x, y) => {
        const newMouse = Vec2(x, y);
        pointer = newMouse;
        if (!mousedown || newMouse.equals(mouse)) {
            return;
        }
        const [dx, dy] = newMouse.sub(mouse).toArray();
        center = center.add(Vec2(dx, dy));
        mouse = newMouse;
        exposedCanvas = canvas.exposure();
    })
    canvas.onMouseWheel(({ deltaY }) => {
        scale = scale + deltaY * 0.001;
        exposedCanvas = canvas.exposure();
    })


    function sdfIntercept(init, dir, element) {
        const maxIte = 50;
        const epsilon = 1e-3;
        let p = init;
        let t = element.distanceTo(p);
        let minT = t;
        for (let i = 0; i < maxIte; i++) {
            p = init.add(dir.scale(t * 0.999));
            const d = element.distanceTo(p);
            t += d;
            if (d < epsilon) {
                return [t, p.add(dir.scale(-epsilon))];
            }
            if (d > minT) {
                return;
            }
            minT = d;
        }
        return;
    }

    // scene
    function Line({ name, positions, color, radius, emissive }) {
        const v = positions[1].sub(positions[0]);
        const n = Vec2(-v.y, v.x).normalize();
        const line = { name, positions, color, radius, emissive };
        line.distanceTo = (p) => {
            const x = p.sub(line.positions[0]);
            const h = Math.min(1, Math.max(0, x.dot(v) / v.dot(v)));
            return x.sub(v.scale(h)).length() - line.radius;
        }

        line.normal = (p) => {
            const epsilon = 1e-3;
            const f = line.distanceTo(p);
            const fx = line.distanceTo(p.add(Vec2(epsilon, 0)));
            const fy = line.distanceTo(p.add(Vec2(0, epsilon)));
            return Vec2((fx - f) / epsilon, (fy - f) / epsilon).normalize();
        }

        line.sample = () => {
            const r = Math.random();
            return positions[0].scale(1 - r).add(positions[1].scale(r));
        }

        line.interceptWith = (init, dir) => {
            const hit = sdfIntercept(init, dir, line);
            if (hit) return [...hit, line.normal(hit[1])];
        }
        return line;
    }

    function Point({ name, position, color, radius, emissive }) {
        const point = { name, position, color, radius, emissive };
        point.distanceTo = (p) => {
            return p.sub(point.position).length() - point.radius;
        }

        point.normal = (p) => {
            return p.sub(point.position).normalize()
        }

        point.sample = () => {
            const theta = 2 * Math.PI * Math.random();
            return Vec2(
                point.radius * Math.cos(theta) + point.position.x,
                point.radius * Math.sin(theta) + point.position.y
            );
        }


        point.interceptWith = (init, dir) => {
            const hit = sdfIntercept(init, dir, point);
            if (hit) return [...hit, point.normal(hit[1])];
        }
        return point;
    }

    function intersectScene(init, dir) {
        let closest = undefined;
        let minDist = Number.MAX_VALUE;
        for (let i = 0; i < scene.length; i++) {
            const e = scene[i];
            const hit = e.interceptWith(init, dir);
            if (hit) {
                const [t, p, n] = hit;
                if (t < minDist) {
                    minDist = t;
                    closest = [p, n, e];
                }
            }
        }
        return closest;
    }

    function trace(x, normal, bounces) {
        if (bounces < 0) return Color.BLACK;
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) < 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) return Color.BLACK;

        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) return color;
        const finalC = trace(p, n, bounces - 1);
        return finalC.mul(color);
    }

    function traceCache(x, normal, bounces) {
        const cachedValue = colorField.get(x);
        if (
            bounces < 3 &&
            cachedValue &&
            cachedValue.count > 1e1 &&
            Math.random() < (cachedValue.count / colorField.total) ** 1e-1
        ) return cachedValue.color;

        if (bounces < 0) return Color.BLACK;
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) < 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) return Color.BLACK;
        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) return color;
        let finalC = traceCache(p, n, bounces - 1);
        finalC = finalC.mul(color);
        if (!finalC.equals(Color.BLACK)) {
            colorField.put(x, finalC);
        }
        return finalC;
    }

    function lightTrace(x, normal, bounces) {
        if (bounces < 0) return colorFromLight(x, normal);
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) < 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) return Color.BLACK;

        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) return color;
        const finalC = lightTrace(p, n, bounces - 1);
        return finalC.mul(color);
    }

    function colorFromLight(p, n) {
        const emissiveElements = scene.filter((e) => e.emissive);
        let c = Color.BLACK
        for (let i = 0; i < emissiveElements.length; i++) {
            const light = emissiveElements[i];
            const lightP = light.sample();
            const v = lightP.sub(p).normalize();
            const hit = intersectScene(p, v);
            if (!hit) continue;
            if (hit) {
                const [p, n, e] = hit;
                const color = e.color;
                if (e.emissive) {
                    c = c.add(color);
                }
            }
        }
        return c.scale(1 / emissiveElements.length);
    }


    function debugTrace(x, normal, bounces) {
        if (bounces < 0) return
        const theta = 2 * Math.PI * Math.random();
        let v = Vec2(Math.cos(theta), Math.sin(theta));
        if (normal && v.dot(normal) <= 0) {
            v = v.scale(-1);
        }
        const hit = intersectScene(x, v);
        if (!hit) {
            if (normal) {
                let p = x.add(v.scale(2));
                canvas.drawLine(
                    Vec2(((x.x / scale) + 1) * (w / 2) + center.x, ((x.y / scale) + 1) * (h / 2) + center.y),
                    Vec2(((p.x / scale) + 1) * (w / 2) + center.x, ((p.y / scale) + 1) * (h / 2) + center.y),
                    () => Color.ofRGB(1, 0, 1)
                )
            }
            return;
        }
        const [p, n, e] = hit;
        const color = e.color;
        if (e.emissive) {
            canvas.drawLine(
                Vec2(((x.x / scale) + 1) * (w / 2) + center.x, ((x.y / scale) + 1) * (h / 2) + center.y),
                Vec2(((p.x / scale) + 1) * (w / 2) + center.x, ((p.y / scale) + 1) * (h / 2) + center.y),
                () => e.color
            )
            return;
        };
        canvas.drawLine(
            Vec2(((x.x / scale) + 1) * (w / 2) + center.x, ((x.y / scale) + 1) * (h / 2) + center.y),
            Vec2(((p.x / scale) + 1) * (w / 2) + center.x, ((p.y / scale) + 1) * (h / 2) + center.y),
            () => color
        )
        debugTrace(p, n, bounces - 1);
    }

    const scene = [
        Point({ name: "light", position: Vec2(), radius: 0.1, emissive: true, color: Color.WHITE }),
        Line({ name: "left", positions: [Vec2(-1.5, -1.5), Vec2(-1.5, 1.5)], radius: 0.1, color: Color.RED }),
        Line({ name: "right", positions: [Vec2(1.5, 1.5), Vec2(1.5, -1.5)], radius: 0.1, color: Color.GREEN }),
        Line({ name: "top", positions: [Vec2(-1.5, 1.5), Vec2(1.5, 1.5)], radius: 0.1, color: Color.WHITE }),
        Line({ name: "wall-1", positions: [Vec2(-0.5, -0.5), Vec2(0, -0.5)], radius: 0.1, color: Color.BLUE }),
        Line({ name: "wall-2", positions: [Vec2(0.5, -1), Vec2(1.0, -1)], radius: 0.1, color: Color.BLUE }),
    ]


    // play
    const play = async ({ time, oldT }) => {
        const newT = new Date().getTime();
        const dt = (new Date().getTime() - oldT) * 1e-3;
        // default
        exposedCanvas
            .map((x, y) => {
                const px = scale * (2 * (x - center.x) / w - 1);
                const py = scale * (2 * (y - center.y) / h - 1);
                return trace(Vec2(px, py), undefined, 10);
            })
        // cached
        // exposedCanvas
        //     .map((x, y) => {
        //         const px = scale * (2 * (x - center.x) / w - 1);
        //         const py = scale * (2 * (y - center.y) / h - 1);
        //         return traceCache(Vec2(px, py), undefined, 10);
        //     })
        // light trace
        // exposedCanvas
        //     .map((x, y) => {
        //         const px = scale * (2 * (x - center.x) / w - 1);
        //         const py = scale * (2 * (y - center.y) / h - 1);
        //         return lightTrace(Vec2(px, py), undefined, 1);
        //     })
        // default /light combination
        // exposedCanvas
        //     .map((x, y) => {
        //         const px = scale * (2 * (x - center.x) / w - 1);
        //         const py = scale * (2 * (y - center.y) / h - 1);
        //         return trace(Vec2(px, py), undefined, 10).scale(0.75)
        //             .add(lightTrace(Vec2(px, py), undefined, 2).scale(0.25))
        //             .toGamma(0.1);
        //     })
        // group aggregation
        // exposedCanvas
        //     .map((x, y) => {
        //         let c = Color.BLACK;
        //         let step = [-1, 0, 1];
        //         let n = step.length;
        //         let nn = n * n;
        //         for (let i = 0; i < nn; i++) {
        //             let j = step[Math.floor(i / n)];
        //             let k = step[i % n];
        //             const px = scale * (2 * ((x + j) - center.x) / w - 1);
        //             const py = scale * (2 * ((y + k) - center.y) / h - 1);
        //             c = c.add(trace(Vec2(px, py), undefined, 10));
        //         }
        //         return c.scale(1 / nn).toGamma(0.0001);
        //     })
        // debug
        // exposedCanvas.map((x, y) => Color.BLACK);
        // debugTrace(
        //     Vec2(
        //         scale * (2 * ((pointer.x - center.x) / w) - 1),
        //         scale * (2 * ((pointer.y - center.y) / h) - 1),
        //     ),
        //     undefined,
        //     1
        // )
        // moving light
        // scene[0].position = Vec2(Math.cos(time), Math.sin(time));
        setTimeout(() => play({
            oldT: newT,
            time: time + dt,
        }));
    }
    setTimeout(() => play({ oldT: new Date().getTime(), time: 0 }))



    // DOM
    function toggleFullScreen(elem) {
        if (!document.fullscreenElement &&    // alternative standard method
            !document.mozFullScreenElement &&
            !document.webkitFullscreenElement &&
            !document.msFullscreenElement) {  // current working methods
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.msRequestFullscreen) {
                elem.msRequestFullscreen();
            } else if (elem.mozRequestFullScreen) {
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
            }
        }
    }
    const canvasDom = canvas.DOM;
    canvasDom.addEventListener("click", () => {
        toggleFullScreen(canvasDom);
    })

    const container = document.createElement("div");
    container.setAttribute("style", "display: flex; flex-grow: 1; margin: auto");
    canvasDom.setAttribute("style", "flex-grow: 0.5")
    container.appendChild(canvasDom);
    document.body.appendChild(container);
</script>

</html>